<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>예측치 대시보드</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      box-sizing: border-box;
    }
    h1 { font-size: 1.4rem; margin-bottom: 4px; }
    p { font-size: 0.9rem; margin-top: 0; color: #555; }

    /* 우상단 버튼 컨테이너: 2열 x 3행 그리드 (오른쪽 정렬) */
    #top-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: grid;
      grid-template-columns: repeat(2, auto);
      grid-auto-rows: auto;
      column-gap: 8px;
      row-gap: 8px;
      z-index: 10;
      justify-items: end;
      justify-content: end;
    }

    .top-button {
      background-color: #e5e5e5;
      border: 1px solid #ccc;
      padding: 6px 10px;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      color: #333;
      white-space: nowrap;
      text-align: center;
      min-width: 110px;
    }
    .top-button:hover {
      background-color: #dcdcdc;
    }

    /* 회차 버튼 */
    #round-buttons {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .round-button {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      padding: 4px 10px;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .round-button.active {
      background-color: #ddd;
      font-weight: 600;
    }

    /* 그룹 버튼 */
    #group-buttons {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .group-button {
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      padding: 4px 10px;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
    }
    .group-button.active {
      background-color: #ddd;
      font-weight: 600;
    }

    #chart-container {
      position: relative;
      height: 70vh;
      max-height: 600px;
      margin-top: 16px;
    }

    /* 회차 통계 오버레이 */
    #roundOverlay {
      position: absolute;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 60%;
      background-color: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: 2px solid #666;
      padding: 24px;
      display: none;
      z-index: 5;
      box-sizing: border-box;
      overflow: auto;
    }
    #roundOverlay h2 {
      margin-top: 0;
      font-size: 1.4rem;
      font-weight: 700;
    }
    #roundOverlay p {
      font-size: 1rem;
      font-weight: 600;
      margin: 6px 0;
      color: #444;
    }
    #roundOverlay p.label-group {
      margin-top: 8px;
      margin-bottom: 4px;
    }
    #roundOverlay ul {
      margin: 4px 0 18px 0;
      padding-left: 20px;
    }
    #roundOverlay li {
      font-size: 0.95rem;
      font-weight: 600;
      margin: 2px 0;
    }
    #roundOverlay p.overall-line,
    #roundOverlay p.closest-line {
      font-size: 1.05rem;
      font-weight: 700;
      color: #000;
      margin-top: 6px;
    }
  </style>
</head>
<body>

  <!-- 상단 우측 버튼들 -->
  <!-- 순서:
       1행: 실제값공개  | CSV 다운로드
       2행: 중심부표시  | 초기화
       3행: 특정값제거  | 한/영 -->
  <div id="top-buttons">
    <button id="toggleActualBtn"    class="top-button">실제값 공개</button>
    <button id="downloadCsvBtn"     class="top-button">CSV 다운로드</button>
    <button id="focusCenterBtn"     class="top-button">중심부 표시</button>
    <button id="resetBtn"           class="top-button">초기화</button>
    <button id="deleteValueOpenBtn" class="top-button">특정값 제거</button>
    <button id="langBtn"            class="top-button">English</button>
  </div>

  <h1 id="pageTitle">예측치 산점도 (실시간)</h1>
  <p id="pageDesc">
    X축: 회차(1~6), Y축: 예측치<br/>
    색깔: <b>그룹 번호</b>별로 구분되어 표시됩니다.<br/>
    점에 마우스를 올리면 <b>학생 이름 & 그 학생의 전체 추세선</b>이 보입니다.<br/>
    아래 회차 버튼을 눌러 해당 회차의 <b>그룹별 평균 / 전체 평균 / 평균에 가장 가까운 학생</b>을 확인할 수 있습니다.
  </p>

  <!-- 회차 버튼들 -->
  <div id="round-buttons">
    <button class="round-button" data-round="1">1회차</button>
    <button class="round-button" data-round="2">2회차</button>
    <button class="round-button" data-round="3">3회차</button>
    <button class="round-button" data-round="4">4회차</button>
    <button class="round-button" data-round="5">5회차</button>
    <button class="round-button" data-round="6">6회차</button>
  </div>

  <!-- 그룹 버튼들 -->
  <div id="group-buttons">
    <button class="group-button" data-group="1">그룹 1</button>
    <button class="group-button" data-group="2">그룹 2</button>
    <button class="group-button" data-group="3">그룹 3</button>
    <button class="group-button" data-group="4">그룹 4</button>
    <button class="group-button" data-group="5">그룹 5</button>
    <button class="group-button" data-group="6">그룹 6</button>
    <button class="group-button" data-group="7">그룹 7</button>
    <button class="group-button" data-group="8">그룹 8</button>
  </div>

  <div id="chart-container">
    <canvas id="predictionChart"></canvas>
    <div id="roundOverlay"></div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/12.3.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyD85EPLcL_j7s-WOQ1FDimMKEYmzBFzapE",
      authDomain: "bean-counting.firebaseapp.com",
      projectId: "bean-counting",
      storageBucket: "bean-counting.firebasestorage.app",
      messagingSenderId: "700257917650",
      appId: "1:700257917650:web:c7821b3e1b1b5f1a366b0b"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const uiDocRef = db.doc('settings/ui');

    const ctx = document.getElementById('predictionChart').getContext('2d');
    const roundOverlayEl = document.getElementById('roundOverlay');
    const roundButtons = document.querySelectorAll('.round-button');
    const groupButtons = document.querySelectorAll('.group-button');

    const ACTUAL_VALUE = 1564;
    const RESET_PASSWORD  = "SNU-TA-Reset-9237!";

    // 상태 변수
    let baseDatasets = [];
    let baseAllDatasets = [];
    let highlightDataset = null;
    let groupMeanDataset = null;
    let actualVisible   = false;
    let focusCenterOn   = false;   // ✅ 중심부(2500까지) 표시 토글
    let allPoints       = [];
    let allPointsAll    = [];
    let roundStats      = {};
    let currentRoundShown = null;
    let currentGroupShown = null;
    let currentLang     = 'ko';

    const TEXT = {
      ko: {
        htmlLang: "ko",
        docTitle: "예측치 대시보드",
        pageTitle: "예측치 산점도 (실시간)",
        pageDescHtml:
          `X축: 회차(1~6), Y축: 예측치<br/>
           색깔: <b>그룹 번호</b>별로 구분되어 표시됩니다.<br/>
           점에 마우스를 올리면 <b>학생 이름 & 그 학생의 전체 추세선</b>이 보입니다.<br/>
           아래 회차 버튼을 눌러 해당 회차의 <b>그룹별 평균 / 전체 평균 / 평균에 가장 가까운 학생</b>을 확인할 수 있습니다.`,
        showActual: "실제값 공개",
        hideActual: "실제값 숨기기",
        downloadCsv: "CSV 다운로드",
        reset: "초기화",
        resetPrompt: "초기화 비밀번호를 입력하세요:",
        resetConfirm: "⚠ 정말 모든 데이터를 삭제할까요?",
        resetDone: "모든 데이터가 초기화되었습니다!",
        badPassword: "비밀번호가 올바르지 않습니다.",
        tooltipUnknown: "이름 미상",
        tooltipLabel: (name, round, value) => `${name} - ${round}회차: ${value}`,
        xTitle: "회차",
        yTitle: "예측치",
        xTick: (v) => `${v}회차`,
        groupLabel: (g) => `그룹 ${g}`,
        trendLabel: (name) => `${name} 추세`,
        overlayTitle: (r) => `${r}회차 통계`,
        overlayGroupMeans: "그룹별 평균",
        overlayNoData: "데이터 없음",
        overlayOverall: (overall) => `전체 평균: <b>${overall}</b>`,
        overlayClosest: (closest) =>
          closest
            ? `전체 평균에 가장 가까운 학생: <b>${closest.name}</b> (값 ${closest.value}, 그룹 ${closest.group})`
            : `전체 평균에 가장 가까운 학생: 정보 없음`,
        roundBtn: (r) => `${r}회차`,
        actualLabel: "실제값",
        groupBtn: (g) => `그룹 ${g}`,
        groupMeanLegend: (g) => `그룹 ${g} 평균`,
        groupMeanTrendLabel: (g) => `그룹 ${g} 평균 추세`,
        groupMeanTooltip: (g, round, value) => `그룹 ${g} 평균 - ${round}회차: ${value}`,
        deleteBtn: "특정값 제거",
        deleteInvalid: "라운드, 이름, 값을 모두 올바르게 입력해주세요.",
        deleteConfirm: (round, name, value, count) =>
          `다음 조건과 일치하는 값 ${count}개를 삭제할까요?\n\n회차: ${round}\n이름: ${name}\n값: ${value}`,
        deleteDone: (count) => `${count}개의 값이 삭제되었습니다.`,
        deleteNotFound: "해당 조건과 일치하는 값이 없습니다.",
        deleteError: "값 삭제 중 오류가 발생했습니다.",
        deletePromptRound: "삭제할 값의 회차(1~6)를 입력하세요:",
        deletePromptName: "삭제할 학생 이름을 정확히 입력하세요:",
        deletePromptValue: "삭제할 수치를 입력하세요:",
        // ✅ 실제값 툴팁: 값만
        actualTooltip: (value) => `실제값: ${value}`,
        // ✅ 중심부(2500까지) 버튼
        focusOn: "중심부 표시",
        focusOff: "전체 범위"
      },
      en: {
        htmlLang: "en",
        docTitle: "Prediction Dashboard",
        pageTitle: "Prediction Scatter Plot (Real-Time)",
        pageDescHtml:
          `X-axis: Round (1–6), Y-axis: Prediction value<br/>
           Colors indicate <b>group numbers</b>.<br/>
           Hover over a point to see the <b>student name & their overall trend line</b>.<br/>
           Use the round buttons below to view <b>group means / overall mean / the student closest to the mean</b>.`,
        showActual: "Show actual value",
        hideActual: "Hide actual value",
        downloadCsv: "Download CSV",
        reset: "Reset",
        resetPrompt: "Enter the reset password:",
        resetConfirm: "⚠ Are you sure you want to delete ALL data?",
        resetDone: "All data has been reset!",
        badPassword: "Incorrect password.",
        tooltipUnknown: "Unknown",
        tooltipLabel: (name, round, value) => `${name} - Round ${round}: ${value}`,
        xTitle: "Round",
        yTitle: "Prediction Value",
        xTick: (v) => `Round ${v}`,
        groupLabel: (g) => `Group ${g}`,
        trendLabel: (name) => `${name} Trend`,
        overlayTitle: (r) => `Round ${r} Statistics`,
        overlayGroupMeans: "Group means",
        overlayNoData: "No data",
        overlayOverall: (overall) => `Overall mean: <b>${overall}</b>`,
        overlayClosest: (closest) =>
          closest
            ? `Closest to overall mean: <b>${closest.name}</b> (value ${closest.value}, group ${closest.group})`
            : `Closest to overall mean: No info`,
        roundBtn: (r) => `Round ${r}`,
        actualLabel: "Actual",
        groupBtn: (g) => `Group ${g}`,
        groupMeanLegend: (g) => `Group ${g} mean`,
        groupMeanTrendLabel: (g) => `Group ${g} mean trend`,
        groupMeanTooltip: (g, round, value) => `Group ${g} mean - Round ${round}: ${value}`,
        deleteBtn: "Remove value",
        deleteInvalid: "Please enter valid round, name, and value.",
        deleteConfirm: (round, name, value, count) =>
          `Delete ${count} value(s) matching:\n\nRound: ${round}\nName: ${name}\nValue: ${value}?`,
        deleteDone: (count) => `${count} value(s) deleted.`,
        deleteNotFound: "No matching values found.",
        deleteError: "An error occurred while deleting the value.",
        deletePromptRound: "Enter the round (1–6) of the value to delete:",
        deletePromptName: "Enter the exact student name of the value to delete:",
        deletePromptValue: "Enter the value (number) to delete:",
        // ✅ Actual 툴팁: 값만
        actualTooltip: (value) => `Actual: ${value}`,
        focusOn: "Focus center",
        focusOff: "Show full range"
      }
    };

    function t() { return TEXT[currentLang] || TEXT.ko; }

    function updateDatasetLabels() {
      const L = t();
      baseDatasets.forEach(ds => {
        if (ds && ds._groupName != null) ds.label = L.groupLabel(ds._groupName);
      });
      if (groupMeanDataset && groupMeanDataset._groupName != null) {
        groupMeanDataset.label = L.groupMeanLegend(groupMeanDataset._groupName);
      }
      if (highlightDataset && highlightDataset._name) {
        highlightDataset.label = L.trendLabel(highlightDataset._name);
      }
    }

    function showRoundOverlay(round) {
      const stats = roundStats[round];
      if (!stats) {
        roundOverlayEl.style.display = 'none';
        currentRoundShown = null;
        return;
      }

      const L = t();

      const groupLines = Object.keys(stats.groupMeans)
        .sort((a, b) => {
          const na = Number(a), nb = Number(b);
          const aNum = Number.isFinite(na), bNum = Number.isFinite(nb);
          if (aNum && bNum) return na - nb;
          return String(a).localeCompare(String(b), 'ko');
        })
        .map(g => `<li>${L.groupLabel(g)}: ${stats.groupMeans[g].toFixed(1)}</li>`)
        .join("");

      const overall = stats.overallMean.toFixed(1);
      const closest = stats.closest;

      roundOverlayEl.innerHTML = `
        <h2>${L.overlayTitle(round)}</h2>
        <p class="label-group">${L.overlayGroupMeans}</p>
        <ul>${groupLines || `<li>${L.overlayNoData}</li>`}</ul>
        <p class="overall-line">${L.overlayOverall(overall)}</p>
        <p class="closest-line">${L.overlayClosest(closest)}</p>
      `;

      roundOverlayEl.style.display = 'block';
      currentRoundShown = round;
    }

    // CSV escape
    function csvEscape(v) {
      const s = String(v ?? "");
      if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    // ✅ 실제값 라인 데이터셋
    function makeActualDataset() {
      const lineData = [];
      for (let r = 1; r <= 6; r++) lineData.push({ x: r, y: ACTUAL_VALUE });
      return {
        type: 'line',
        label: t().actualLabel,
        data: lineData,
        borderColor: 'red',
        borderWidth: 4,
        pointRadius: 0,
        pointHitRadius: 10,
        pointHoverRadius: 0,
        fill: false,
        _isActualDataset: true
      };
    }

    function buildGroupMeanDataset() {
      if (currentGroupShown == null) {
        groupMeanDataset = null;
        return;
      }
      const g = String(currentGroupShown);
      const L = t();
      const points = [];

      for (let r = 1; r <= 6; r++) {
        const stats = roundStats[r];
        if (!stats || !stats.groupMeans) continue;
        const mean = stats.groupMeans[g];
        if (typeof mean === 'number' && !isNaN(mean)) {
          points.push({ x: r, y: mean, group: g, _isGroupMean: true });
        }
      }

      if (points.length === 0) {
        groupMeanDataset = null;
        return;
      }

      groupMeanDataset = {
        type: 'scatter',
        label: L.groupMeanLegend(g),
        data: points,
        pointRadius: 6,
        pointBackgroundColor: '#000000',
        pointBorderColor: '#000000',
        showLine: false,
        _isGroupMeanDataset: true,
        _groupName: g
      };
    }

    function refreshFilteredBase() {
      if (currentGroupShown == null) {
        baseDatasets = [...baseAllDatasets];
        allPoints = [...allPointsAll];
      } else {
        const g = String(currentGroupShown);
        baseDatasets = baseAllDatasets.filter(ds => String(ds._groupName) === g);
        allPoints = allPointsAll.filter(p => String(p.group) === g);
      }
      buildGroupMeanDataset();
    }

    function applyGroupFilterUI() {
      groupButtons.forEach(b => b.classList.remove('active'));
      if (currentGroupShown != null) {
        const activeBtn = document.querySelector(`.group-button[data-group="${currentGroupShown}"]`);
        if (activeBtn) activeBtn.classList.add('active');
      }
    }

    function applyDatasets() {
      const datasets = [...baseDatasets];
      if (currentGroupShown != null && groupMeanDataset) datasets.push(groupMeanDataset);
      if (actualVisible) datasets.push(makeActualDataset());
      if (highlightDataset) datasets.push(highlightDataset);
      predictionChart.data.datasets = datasets;
      predictionChart.update();
    }

    // ✅ 툴팁 콜백 (Actual + 그룹평균 + 학생)
    function tooltipLabelCallback(context) {
      const L = t();
      const p = context.raw;

      // 1) 실제값 라인
      if (context.dataset && context.dataset._isActualDataset) {
        return L.actualTooltip(ACTUAL_VALUE);  // 항상 "실제값: 1564 / Actual: 1564"
      }

      const round = context.parsed.x;
      const value = context.parsed.y;

      // 2) 그룹 평균 점
      if (p && p._isGroupMean && p.group != null) {
        const g = String(p.group);
        return L.groupMeanTooltip(g, round, value);
      }

      // 3) 일반 학생 점
      const name = (p && p.name) ? p.name : L.tooltipUnknown;
      return L.tooltipLabel(name, round, value);
    }

    const predictionChart = new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: {
          mode: 'point',
          intersect: false
        },
        plugins: {
          legend: { display: true },
          tooltip: {
            mode: 'point',
            intersect: false,
            callbacks: {
              label: tooltipLabelCallback
            }
          }
        },
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            title: { display: true, text: '회차' },
            ticks: { stepSize: 1, callback: v => `${v}회차` },
            min: 1,
            max: 6
          },
          y: {
            title: { display: true, text: '예측치' }
            // y.max는 focusCenterOn에 따라 동적으로 설정
          }
        },
        onHover: (event, activeElements, chart) => {
          if (activeElements.length > 0) {
            const first = activeElements[0];
            const dsIndex = first.datasetIndex;
            const index = first.index;
            const ds = chart.data.datasets[dsIndex];
            const point = ds.data[index];

            // 그룹 평균 점 위: 그룹 평균 추세선
            if (point && point._isGroupMean && point.group) {
              const g = String(point.group);
              const points = [];
              for (let r = 1; r <= 6; r++) {
                const stats = roundStats[r];
                if (!stats || !stats.groupMeans) continue;
                const mean = stats.groupMeans[g];
                if (typeof mean === 'number' && !isNaN(mean)) {
                  points.push({ x: r, y: mean });
                }
              }
              if (points.length > 1) {
                highlightDataset = {
                  type: 'line',
                  label: t().groupMeanTrendLabel(g),
                  data: points,
                  borderColor: 'rgba(0,0,0,0.7)',
                  borderWidth: 2,
                  pointRadius: 0,
                  fill: false,
                  borderDash: [4, 3]
                };
              } else {
                highlightDataset = null;
              }
              applyDatasets();
              return;
            }

            // 학생 점 위: 학생 추세선
            const name = point && point.name;
            if (name) {
              const personPoints = allPoints
                .filter(p => p.name === name)
                .sort((a, b) => a.round - b.round)
                .map(p => ({ x: p.round, y: p.value }));

              if (personPoints.length > 1) {
                highlightDataset = {
                  type: 'line',
                  label: t().trendLabel(name),
                  data: personPoints,
                  borderColor: 'rgba(0,0,0,0.6)',
                  borderWidth: 2,
                  pointRadius: 0,
                  fill: false,
                  borderDash: [4, 3],
                  _name: name
                };
              } else {
                highlightDataset = null;
              }
              applyDatasets();
            }
          } else {
            if (highlightDataset) {
              highlightDataset = null;
              applyDatasets();
            }
          }
        }
      }
    });
    window.predictionChart = predictionChart;

    const groupColors = [
      '#e41a1c', '#377eb8', '#4daf4a', '#984ea3',
      '#ff7f00', '#a65628', '#f781bf', '#999999'
    ];

    db.collection('predictions')
      .orderBy('round', 'asc')
      .onSnapshot((snapshot) => {
        const groupMap = {};
        allPointsAll = [];

        snapshot.forEach((doc) => {
          const data = doc.data();
          const group = (data.group || '기타').toString();
          if (typeof data.round === 'number' && typeof data.value === 'number') {
            if (!groupMap[group]) groupMap[group] = [];
            groupMap[group].push({ x: data.round, y: data.value, name: data.name || '' });
            allPointsAll.push({ name: data.name || '', group, round: data.round, value: data.value });
          }
        });

        const groupNames = Object.keys(groupMap).sort((a, b) => {
          const na = Number(a), nb = Number(b);
          const aNum = Number.isFinite(na), bNum = Number.isFinite(nb);
          if (aNum && bNum) return na - nb;
          return String(a).localeCompare(String(b), 'ko');
        });

        baseAllDatasets = groupNames.map((groupName, idx) => ({
          label: t().groupLabel(groupName),
          data: groupMap[groupName],
          pointRadius: 4,
          backgroundColor: groupColors[idx % groupColors.length],
          _groupName: groupName
        }));

        // 회차 통계 계산
        roundStats = {};
        const roundGroupValues = {};
        const roundAllValues   = {};

        allPointsAll.forEach(p => {
          if (!roundGroupValues[p.round]) roundGroupValues[p.round] = {};
          if (!roundGroupValues[p.round][p.group]) roundGroupValues[p.round][p.group] = [];
          roundGroupValues[p.round][p.group].push(p.value);

          if (!roundAllValues[p.round]) roundAllValues[p.round] = [];
          roundAllValues[p.round].push({ name: p.name, group: p.group, value: p.value });
        });

        for (let r = 1; r <= 6; r++) {
          if (!roundAllValues[r]) continue;

          const groupMeans = {};
          Object.keys(roundGroupValues[r] || {}).forEach(g => {
            const arr = roundGroupValues[r][g];
            const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
            groupMeans[g] = mean;
          });

          const allArr = roundAllValues[r];
          const overallMean = allArr.reduce((a, p) => a + p.value, 0) / allArr.length;

          let closest = null;
          let bestDiff = Infinity;
          allArr.forEach(p => {
            const diff = Math.abs(p.value - overallMean);
            if (diff < bestDiff) {
              bestDiff = diff;
              closest = p;
            }
          });

          roundStats[r] = { groupMeans, overallMean, closest };
        }

        refreshFilteredBase();
        applyDatasets();
      });

    function applyLanguageToStaticUI() {
      const L = t();

      document.documentElement.lang = L.htmlLang;
      document.title = L.docTitle;

      document.getElementById('pageTitle').textContent = L.pageTitle;
      document.getElementById('pageDesc').innerHTML = L.pageDescHtml;

      // 우상단 버튼 텍스트
      document.getElementById('toggleActualBtn').textContent =
        actualVisible ? L.hideActual : L.showActual;

      document.getElementById('downloadCsvBtn').textContent = L.downloadCsv;

      document.getElementById('focusCenterBtn').textContent =
        focusCenterOn ? L.focusOff : L.focusOn;

      document.getElementById('resetBtn').textContent = L.reset;
      document.getElementById('deleteValueOpenBtn').textContent = L.deleteBtn;
      document.getElementById('langBtn').textContent = (currentLang === "ko") ? "English" : "한국어";

      roundButtons.forEach(btn => {
        const r = parseInt(btn.dataset.round, 10);
        btn.textContent = L.roundBtn(r);
      });

      groupButtons.forEach(btn => {
        const g = btn.dataset.group;
        btn.textContent = L.groupBtn(g);
      });

      if (!window.predictionChart) return;

      buildGroupMeanDataset();
      predictionChart.options.scales.x.title.text = L.xTitle;
      predictionChart.options.scales.y.title.text = L.yTitle;
      predictionChart.options.scales.x.ticks.callback = (v) => L.xTick(v);
      predictionChart.options.plugins.tooltip.callbacks.label = tooltipLabelCallback;

      updateDatasetLabels();
      if (currentRoundShown != null) showRoundOverlay(currentRoundShown);

      predictionChart.update();
    }

    uiDocRef.onSnapshot(async (doc) => {
      if (!doc.exists) {
        try { await uiDocRef.set({ lang: "ko" }, { merge: true }); } catch (e) {}
        return;
      }
      const lang = (doc.data() && doc.data().lang) ? doc.data().lang : "ko";
      if (lang !== "ko" && lang !== "en") return;

      currentLang = lang;
      applyLanguageToStaticUI();
    });

    document.getElementById("downloadCsvBtn").addEventListener("click", async () => {
      const snapshot = await db.collection("predictions").get();
      const rows = [["name","group","round","value","timestamp"]];
      snapshot.forEach(doc => {
        const d = doc.data();
        const ts = d.createdAt && d.createdAt.toDate ? d.createdAt.toDate().toISOString() : "";
        rows.push([d.name ?? "", d.group ?? "", d.round ?? "", d.value ?? "", ts]);
      });

      const csvContent = "data:text/csv;charset=utf-8,\ufeff" +
        rows.map(row => row.map(csvEscape).join(",")).join("\n");
      const link = document.createElement("a");
      link.href = encodeURI(csvContent);
      link.download = "predictions_backup_" + new Date().toISOString().slice(0, 10) + ".csv";
      link.click();
    });

    // 실제값 토글
    document.getElementById("toggleActualBtn").addEventListener("click", () => {
      const L = t();
      actualVisible = !actualVisible;
      document.getElementById("toggleActualBtn").textContent =
        actualVisible ? L.hideActual : L.showActual;
      applyDatasets();
    });

    // 중심부(2500까지) 표시 토글
    document.getElementById("focusCenterBtn").addEventListener("click", () => {
      const L = t();
      focusCenterOn = !focusCenterOn;

      // y축 max 설정
      if (focusCenterOn) {
        predictionChart.options.scales.y.max = 2500;
      } else {
        // 자동 스케일로 되돌리기
        delete predictionChart.options.scales.y.max;
      }

      document.getElementById("focusCenterBtn").textContent =
        focusCenterOn ? L.focusOff : L.focusOn;

      predictionChart.update();
    });

    // 언어 토글
    document.getElementById("langBtn").addEventListener("click", async () => {
      const nextLang = (currentLang === "ko") ? "en" : "ko";
      try {
        await uiDocRef.set({ lang: nextLang }, { merge: true });
      } catch (e) {
        alert("Failed to change language. (Firestore write blocked)");
      }
    });

    function hideRoundOverlay() {
      roundOverlayEl.style.display = 'none';
      currentRoundShown = null;
    }

    roundButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const round = parseInt(btn.dataset.round, 10);
        if (currentRoundShown === round) {
          hideRoundOverlay();
          roundButtons.forEach(b => b.classList.remove('active'));
        } else {
          showRoundOverlay(round);
          roundButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
      });
    });

    // 그룹 필터 버튼
    groupButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const g = btn.dataset.group;
        currentGroupShown = (currentGroupShown === g) ? null : g;

        refreshFilteredBase();
        applyGroupFilterUI();
        if (highlightDataset) highlightDataset = null;

        applyDatasets();
      });
    });

    // 개별 값 삭제: 상단 "특정값 제거" 버튼 → prompt 3개(회차/이름/값)
    document.getElementById('deleteValueOpenBtn').addEventListener('click', async () => {
      const L = t();

      const roundInput = prompt(L.deletePromptRound);
      if (roundInput === null) return; // 취소
      const round = parseInt(roundInput.trim(), 10);

      const nameInputRaw = prompt(L.deletePromptName);
      if (nameInputRaw === null) return;
      const nameInput = nameInputRaw.trim();

      const valueInput = prompt(L.deletePromptValue);
      if (valueInput === null) return;
      const value = parseFloat(valueInput.trim());

      if (!round || isNaN(round) || !nameInput || isNaN(value)) {
        alert(L.deleteInvalid);
        return;
      }

      try {
        const query = db.collection('predictions')
          .where('round', '==', round)
          .where('name', '==', nameInput)
          .where('value', '==', value);

        const snapshot = await query.get();
        const count = snapshot.size;

        if (count === 0) {
          alert(L.deleteNotFound);
          return;
        }

        const ok = confirm(L.deleteConfirm(round, nameInput, value, count));
        if (!ok) return;

        const batch = db.batch();
        snapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();

        alert(L.deleteDone(count));
      } catch (e) {
        console.error(e);
        alert(L.deleteError);
      }
    });

    // 전체 초기화
    document.getElementById("resetBtn").addEventListener("click", async () => {
      const L = t();
      const input = prompt(L.resetPrompt);

      if (input !== RESET_PASSWORD) {
        alert(L.badPassword);
        return;
      }

      const really = confirm(L.resetConfirm);
      if (!really) return;

      const snapshot = await db.collection("predictions").get();
      const batch = db.batch();
      snapshot.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      alert(L.resetDone);
      hideRoundOverlay();
      roundButtons.forEach(b => b.classList.remove('active'));
    });
  </script>
</body>
</html>
