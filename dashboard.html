<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì˜ˆì¸¡ì¹˜ ëŒ€ì‹œë³´ë“œ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      box-sizing: border-box;
    }
    h1 { font-size: 1.4rem; margin-bottom: 4px; }
    p { font-size: 0.9rem; margin-top: 0; color: #555; }

    /* ìš°ìƒë‹¨ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ */
    #top-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .top-button {
      background-color: #e5e5e5;
      border: 1px solid #ccc;
      padding: 6px 10px;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      color: #333;
    }
    .top-button:hover {
      background-color: #dcdcdc;
    }

    #chart-container {
      position: relative;
      height: 70vh;
      max-height: 600px;
      margin-top: 40px;
    }

    #roundInfo {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #444;
      white-space: pre-line; /* ì¤„ë°”ê¿ˆ í‘œì‹œìš© */
    }
  </style>
</head>
<body>

  <!-- ìƒë‹¨ ìš°ì¸¡ ë²„íŠ¼ë“¤ -->
  <div id="top-buttons">
    <button id="downloadCsvBtn" class="top-button">CSV ë‹¤ìš´ë¡œë“œ</button>
    <button id="toggleActualBtn" class="top-button">Actual 1616 í‘œì‹œ</button>
    <button id="resetBtn" class="top-button">ì´ˆê¸°í™”</button>
  </div>

  <h1>ì˜ˆì¸¡ì¹˜ ì‚°ì ë„ (ì‹¤ì‹œê°„)</h1>
  <p>
    Xì¶•: íšŒì°¨(1~6), Yì¶•: ì˜ˆì¸¡ì¹˜<br/>
    ìƒ‰ê¹”: <b>ê·¸ë£¹ ë²ˆí˜¸</b>ë³„ë¡œ êµ¬ë¶„ë˜ì–´ í‘œì‹œë©ë‹ˆë‹¤.<br/>
    ì ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ <b>í•™ìƒ ì´ë¦„ & ê·¸ í•™ìƒì˜ ì „ì²´ ì¶”ì„¸ì„ </b>ì´ ë³´ì…ë‹ˆë‹¤.<br/>
    ì•„ë˜ ì •ë³´ì°½ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦° íšŒì°¨ì˜ <b>ê·¸ë£¹ë³„ í‰ê·  / ì „ì²´ í‰ê·  / í‰ê· ì— ê°€ì¥ ê°€ê¹Œìš´ í•™ìƒ</b>ì´ í‘œì‹œë©ë‹ˆë‹¤.
  </p>

  <div id="chart-container">
    <canvas id="predictionChart"></canvas>
  </div>

  <div id="roundInfo"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/12.3.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    /* ğŸ”¹ Firebase Config (submit.htmlê³¼ ë™ì¼í•˜ê²Œ êµì²´í•  ê²ƒ!) */
    const firebaseConfig = {
      apiKey: "AIzaSyD85EPLcL_j7s-WOQ1FDimMKEYmzBFzapE",
      authDomain: "bean-counting.firebaseapp.com",
      projectId: "bean-counting",
      storageBucket: "bean-counting.firebasestorage.app",
      messagingSenderId: "700257917650",
      appId: "1:700257917650:web:c7821b3e1b1b5f1a366b0b"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    const ctx = document.getElementById('predictionChart').getContext('2d');
    const roundInfoEl = document.getElementById('roundInfo');

    const ACTUAL_VALUE = 1616;
    const RESET_PASSWORD  = "SNU-TA-Reset-9237!";
    const ACTUAL_PASSWORD = "1616";

    // ìƒíƒœ ì €ì¥ìš© ì „ì—­ ë³€ìˆ˜ë“¤
    let baseDatasets = [];        // ê·¸ë£¹ë³„ ì ë“¤ë§Œ ë“¤ì–´ìˆëŠ” ê¸°ë³¸ ë°ì´í„°ì…‹
    let highlightDataset = null;  // í•™ìƒ ê°œë³„ ì¶”ì„¸ì„ 
    let actualVisible   = false;  // actual ì„  í‘œì‹œ ì—¬ë¶€
    let actualUnlocked  = false;  // actual ë¹„ë°€ë²ˆí˜¸ í†µê³¼ ì—¬ë¶€
    let allPoints = [];           // {name, group, round, value}
    let roundStats = {};          // íšŒì°¨ë³„ í†µê³„ ì •ë³´

    // ì‹¤ì œê°’(1616) ê°€ë¡œì„  ë°ì´í„°ì…‹ ìƒì„± í•¨ìˆ˜
    function makeActualDataset() {
      const lineData = [];
      for (let r = 1; r <= 6; r++) {
        lineData.push({ x: r, y: ACTUAL_VALUE });
      }
      return {
        type: 'line',
        label: `Actual (${ACTUAL_VALUE})`,
        data: lineData,
        borderColor: 'red',
        borderWidth: 3,
        pointRadius: 0,
        fill: false
      };
    }

    // ì°¨íŠ¸ ë°ì´í„°ì…‹ì„ í˜„ì¬ ìƒíƒœì— ë§ê²Œ ì¬êµ¬ì„±
    function applyDatasets() {
      const datasets = [...baseDatasets];

      if (actualVisible) {
        datasets.push(makeActualDataset());
      }

      if (highlightDataset) {
        datasets.push(highlightDataset);
      }

      predictionChart.data.datasets = datasets;
      predictionChart.update();
    }

    // ì°¨íŠ¸ ì´ˆê¸°í™”
    const predictionChart = new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true },
          tooltip: {
            callbacks: {
              label: (context) => {
                const p = context.raw; // {x, y, name}
                const name = p.name || 'ì´ë¦„ ë¯¸ìƒ';
                const round = context.parsed.x;
                const value = context.parsed.y;
                return `${name} - ${round}íšŒì°¨: ${value}`;
              }
            }
          }
        },
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            title: { display: true, text: 'íšŒì°¨' },
            ticks: { stepSize: 1, callback: v => `${v}íšŒì°¨` },
            min: 1,
            max: 6
          },
          y: {
            title: { display: true, text: 'ì˜ˆì¸¡ì¹˜' }
          }
        },
        // í¬ì¸íŠ¸/ì¶• ìœ„ë¡œ ë§ˆìš°ìŠ¤ ì˜¬ë ¸ì„ ë•Œ
        onHover: (event, activeElements, chart) => {
          // 1) í¬ì¸íŠ¸ ìœ„ì— ìˆì„ ë• í•´ë‹¹ í•™ìƒì˜ ì „ì²´ ì¶”ì„¸ì„  ê·¸ë¦¬ê¸°
          if (activeElements.length > 0) {
            const first = activeElements[0];
            const dsIndex = first.datasetIndex;
            const index = first.index;
            const ds = chart.data.datasets[dsIndex];
            const point = ds.data[index];

            const name = point.name;
            if (name) {
              const personPoints = allPoints
                .filter(p => p.name === name)
                .sort((a, b) => a.round - b.round)
                .map(p => ({ x: p.round, y: p.value }));

              if (personPoints.length > 1) {
                highlightDataset = {
                  type: 'line',
                  label: `${name} ì¶”ì„¸`,
                  data: personPoints,
                  borderColor: 'rgba(0,0,0,0.6)',
                  borderWidth: 2,
                  pointRadius: 0,
                  fill: false,
                  borderDash: [4, 3]
                };
              } else {
                highlightDataset = null;
              }
              applyDatasets();
            }
          } else {
            // ë§ˆìš°ìŠ¤ê°€ í¬ì¸íŠ¸ë¥¼ ë²—ì–´ë‚˜ë©´ í•™ìƒ ì¶”ì„¸ì„  ì œê±°
            if (highlightDataset) {
              highlightDataset = null;
              applyDatasets();
            }
          }

          // 2) ë§ˆìš°ìŠ¤ê°€ ì–´ëŠ íšŒì°¨ ê·¼ì²˜ì¸ì§€ì— ë”°ë¼ íšŒì°¨ë³„ í†µê³„ í‘œì‹œ
          const xScale = chart.scales.x;
          const xVal = xScale.getValueForPixel(event.x);
          const round = Math.round(xVal);

          if (round >= 1 && round <= 6 && roundStats[round]) {
            const stats = roundStats[round];

            const groupParts = Object.keys(stats.groupMeans)
              .sort()
              .map(g => `ê·¸ë£¹ ${g}: ${stats.groupMeans[g].toFixed(1)}`)
              .join(", ");

            const overallMean = stats.overallMean.toFixed(1);
            const closest = stats.closest;

            let text = `${round}íšŒì°¨ í†µê³„\n`;
            text += `ê·¸ë£¹ë³„ í‰ê· : ${groupParts}\n`;
            text += `ì „ì²´ í‰ê· : ${overallMean}\n`;
            if (closest) {
              text += `ì „ì²´ í‰ê· ì— ê°€ì¥ ê°€ê¹Œìš´ í•™ìƒ: ${closest.name} (ê°’ ${closest.value}, ê·¸ë£¹ ${closest.group})`;
            }

            roundInfoEl.textContent = text;
          } else {
            roundInfoEl.textContent = '';
          }
        },
        onLeave: () => {
          // ì°¨íŠ¸ ì˜ì—­ì„ ë– ë‚˜ë©´ íšŒì°¨ ì •ë³´ëŠ” ì§€ìš°ë˜,
          // í•™ìƒ ì¶”ì„¸ì„ ì€ onHoverì—ì„œ ì´ë¯¸ ì œê±°ë¨.
          roundInfoEl.textContent = '';
        }
      }
    });

    /* ğŸ”¹ ê·¸ë£¹ë³„ ìƒ‰ìƒ */
    const groupColors = [
      '#e41a1c', '#377eb8', '#4daf4a', '#984ea3',
      '#ff7f00', '#a65628', '#f781bf', '#999999'
    ];

    /* ğŸ”¹ Firestore ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆ */
    db.collection('predictions')
      .orderBy('round', 'asc')
      .onSnapshot((snapshot) => {
        const groupMap = {};   // { groupName: [{x, y, name}, ...] }
        allPoints = [];

        snapshot.forEach((doc) => {
          const data = doc.data();
          const group = (data.group || 'ê¸°íƒ€').toString();
          if (typeof data.round === 'number' && typeof data.value === 'number') {
            if (!groupMap[group]) groupMap[group] = [];
            groupMap[group].push({
              x: data.round,
              y: data.value,
              name: data.name || ''
            });
            allPoints.push({
              name: data.name || '',
              group,
              round: data.round,
              value: data.value
            });
          }
        });

        // ê¸°ë³¸ ë°ì´í„°ì…‹ êµ¬ì„±
        const groupNames = Object.keys(groupMap).sort();
        baseDatasets = groupNames.map((groupName, idx) => ({
          label: `ê·¸ë£¹ ${groupName}`,
          data: groupMap[groupName],
          pointRadius: 4,
          backgroundColor: groupColors[idx % groupColors.length]
        }));

        // íšŒì°¨ë³„ í†µê³„ ê³„ì‚°
        roundStats = {};
        const roundGroupValues = {};  // { round: { group: [values] } }
        const roundAllValues   = {};  // { round: [ {name,group,value} ] }

        allPoints.forEach(p => {
          if (!roundGroupValues[p.round]) roundGroupValues[p.round] = {};
          if (!roundGroupValues[p.round][p.group]) roundGroupValues[p.round][p.group] = [];
          roundGroupValues[p.round][p.group].push(p.value);

          if (!roundAllValues[p.round]) roundAllValues[p.round] = [];
          roundAllValues[p.round].push({ name: p.name, group: p.group, value: p.value });
        });

        for (let r = 1; r <= 6; r++) {
          if (!roundAllValues[r]) continue;

          const groupMeans = {};
          Object.keys(roundGroupValues[r] || {}).forEach(g => {
            const arr = roundGroupValues[r][g];
            const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
            groupMeans[g] = mean;
          });

          const allArr = roundAllValues[r];
          const overallMean = allArr.reduce((a, p) => a + p.value, 0) / allArr.length;

          let closest = null;
          let bestDiff = Infinity;
          allArr.forEach(p => {
            const diff = Math.abs(p.value - overallMean);
            if (diff < bestDiff) {
              bestDiff = diff;
              closest = p;
            }
          });

          roundStats[r] = {
            groupMeans,
            overallMean,
            closest
          };
        }

        // í˜„ì¬ ìƒíƒœ(actual/í•˜ì´ë¼ì´íŠ¸)ë¥¼ ë°˜ì˜í•´ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        applyDatasets();
      });

    /* ------------------------------- */
    /*  ğŸ”¥ CSV ë‹¤ìš´ë¡œë“œ (BOM í¬í•¨, í•œê¸€ ì•ˆ ê¹¨ì§) */
    /* ------------------------------- */

    document.getElementById("downloadCsvBtn").addEventListener("click", async () => {
      const snapshot = await db.collection("predictions").get();
      const rows = [["name","group","round","value","timestamp"]];

      snapshot.forEach(doc => {
        const d = doc.data();
        const ts =
          d.createdAt && d.createdAt.toDate
            ? d.createdAt.toDate().toISOString()
            : "";
        rows.push([
          d.name ?? "",
          d.group ?? "",
          d.round ?? "",
          d.value ?? "",
          ts
        ]);
      });

      const csvContent =
        "data:text/csv;charset=utf-8,\ufeff" +
        rows.map(e => e.join(",")).join("\n");

      const link = document.createElement("a");
      link.href = encodeURI(csvContent);
      link.download =
        "predictions_backup_" + new Date().toISOString().slice(0, 10) + ".csv";
      link.click();
    });

    /* ------------------------------- */
    /*  ğŸ”¥ Actual(1616) ê°€ë¡œì„  í† ê¸€  */
    /*     - ì²˜ìŒ ê³µê°œí•  ë•Œë§Œ ë¹„ë°€ë²ˆí˜¸(1616) ìš”êµ¬ */
    /* ------------------------------- */

    document.getElementById("toggleActualBtn").addEventListener("click", () => {
      if (!actualUnlocked) {
        const input = prompt("Actual ê°’ì„ ì²˜ìŒ ê³µê°œí•  ë•Œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
        if (input !== ACTUAL_PASSWORD) {
          alert("ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
          return;
        }
        actualUnlocked = true;
      }

      actualVisible = !actualVisible;
      document.getElementById("toggleActualBtn").textContent =
        actualVisible ? "Actual 1616 ìˆ¨ê¸°ê¸°" : "Actual 1616 í‘œì‹œ";

      applyDatasets();
    });

    /* ------------------------------- */
    /*  ğŸ”¥ ì´ˆê¸°í™” ê¸°ëŠ¥ (ë¹„ë°€ë²ˆí˜¸ í•„ìš”) */
    /* ------------------------------- */

    document.getElementById("resetBtn").addEventListener("click", async () => {
      const input = prompt("ì´ˆê¸°í™” ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");

      if (input !== RESET_PASSWORD) {
        alert("ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return;
      }

      const really = confirm("âš  ì •ë§ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí• ê¹Œìš”?");
      if (!really) return;

      const snapshot = await db.collection("predictions").get();
      const batch = db.batch();

      snapshot.forEach(doc => batch.delete(doc.ref));
      await batch.commit();

      alert("ëª¨ë“  ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!");
    });
  </script>
</body>
</html>
